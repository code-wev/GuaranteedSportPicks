import { NextFunction, Request, Response } from 'express';
import z, { ZodError } from 'zod';
import config from '../config/config';
import ServerResponse from '../helpers/responses/custom-response';

/**
 * Handles errors generated by Zod schema validation.
 *
 * @param req - The request object.
 * @param res - The response object.
 * @param zodErr - The Zod error object.
 * @returns The response object with error details.
 */
const zodErrorHandler = (req: Request, res: Response, zodErr: ZodError): Response => {
  // Extract and format errors from the Zod error object
  const errors = zodErr.issues.map((err) => ({
    field: err?.path?.join(', '),
    message: err?.message,
  }));

  // Log errors in any mode except production
  if (config.NODE_ENV !== 'production') {
    console.log(errors);
  }

  // Send error response using the global response helper
  return ServerResponse(res, false, 400, 'Validation error', null, errors);
};

/**
 * Helper (assuming you have something like this)
 */
export function validate<T extends z.ZodTypeAny>(
  schema: T,
  source: 'body' | 'params' | 'query' | 'mixed' = 'body'
) {
  return (req: Request, res: Response, next: NextFunction) => {
    let dataToValidate: any;

    switch (source) {
      case 'body':
        dataToValidate = req.body;
        break;
      case 'params':
        dataToValidate = req.params;
        break;
      case 'query':
        dataToValidate = req.query;
        break;
      case 'mixed':
        // Useful when you need both params + body or query + params
        dataToValidate = { ...req.params, ...req.query, ...req.body };
        break;
      default:
        dataToValidate = req.body;
    }

    const result = schema.safeParse(dataToValidate);

    if (!result.success) {
      return zodErrorHandler(req, res, result.error);
    }

    // Attach validated data to the appropriate request property
    // This makes it type-safe and convenient in controllers
    switch (source) {
      case 'body':
        req.body = result.data;
        break;
      case 'params':
        req.params = result.data as any; // careful with types if needed
        break;
      case 'query':
        (req as any).validatedQuery = result.data;
        break;
      // For mixed, you usually want to spread into req
      case 'mixed':
        (req as any).validated = result.data;
        break;
    }

    next();
  };
}

export const validateBody = <T extends z.ZodTypeAny>(schema: T) => validate(schema, 'body');

export const validateParams = <T extends z.ZodTypeAny>(schema: T) => validate(schema, 'params');

export const validateQuery = <T extends z.ZodTypeAny>(schema: T) => validate(schema, 'query');
